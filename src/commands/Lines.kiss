// Perform a synchronous transformation on each selected line of text
(function _mapLinesSync [selectedText mapFunc]
    (let [:String->String safeMapFunc
                    ->[line]
                        (ifLet [trimmedLine (StringTools.trim line)] (try (mapFunc trimmedLine) (catch [e] (Std.string e))) "")
                mappedText 
                    (.join
                        (map
                            (.split selectedText "\n")
                            safeMapFunc)
                        "\n")]
            (.edit activeTextEditor
                (lambda [e]
                    (let [editor activeTextEditor]
                        (e.delete editor.selection)
                        (e.insert editor.selection.active mappedText))))))

(defCommand context mapLinesSync "Transform the selected text lines using a String->String kiss function" "C-; C-m" []
    (awaitLet [mapFuncStr (inputEditor "mapLinesFunc.kiss" "a String->String function through which to map the selected lines")]
        (let [:String->String mapFunc (evalString mapFuncStr)]
            (_mapLinesSync (selectedText) mapFunc))))

// Sort the selected lines of text using a comparison function (String,String) -> Int
(function _sortLinesSync [selectedText :Dynamic compareFunc]
    (let [lines (selectedText.split "\n")]
        (lines.sort compareFunc)
        (.edit activeTextEditor
            (lambda [e]
                (let [editor activeTextEditor]
                    (e.delete editor.selection)
                    (e.insert editor.selection.active (lines.join "\n")))))))

(defCommand context sortLinesSync "Sort the selected text lines using a (String,String)->Int comparator function" "" []
    (awaitLet [compareFuncStr (inputEditor "sortLinesFunc.kiss" "a (String,String) -> Int function with which to sort the selected lines")]
        (_sortLinesSync (selectedText) (if (< 0 compareFuncStr.length) (evalString compareFuncStr) Reflect.compare))))

(defCommand context sortLinesSyncDefault "Sort the selected lines lexicographically" "C-; C-s" []
    (_sortLinesSync (selectedText) Reflect.compare))

(defCommand context sortLinesSyncEOL "Sort the selected lines lexicographically from the end of each line" "" []
    (_sortLinesSync (selectedText) ->[:String s1 :String s2] (Reflect.compare (s1.reverse) (s2.reverse))))

// Example: editMonster(monster, MONSTER) -> editItem(item, ITEM)
(defCommand context findReplaceTokenMatchCase "Find and replace a token, matching case" "" []
    (localVar &mut idx 0)
    (localVar &mut output "")
    (awaitLet [find (inputBox)
                replace (inputBox)
                &sync findLower (find.toLowerCase)
                &sync text (selectedText)
                &sync textLower (text.toLowerCase)
                &sync textHits []
                &sync textHitTokens []]
        (unless text (print "No text selected!") (return))
        (unless find (print "Nothing to find!") (return))
        (while (< idx text.length)
            (set idx (textLower.indexOf findLower idx))
            (when (= -1 idx) (break))
            (textHits.push idx)
            (textHitTokens.push (text.substr idx find.length))
            (+= idx find.length))
        (set idx 0)
        (doFor [hit :String hitToken] (zip textHits textHitTokens)
            (+= output (text.substr idx (- hit idx)))
            (cond
                // all caps
                ((hitToken.isUpperCase)
                    (+= output (replace.toUpperCase)))
                // all lower
                ((hitToken.isLowerCase)
                    (+= output (replace.toLowerCase)))
                // first letter capitalized
                ((.isUpperCase (hitToken.charAt 0))
                    (+= output (replace.toUpperCamel))))
            (set idx (+ hit find.length)))
        (+= output (text.substr idx))
        (.edit activeTextEditor
            (lambda [e]
                (let [editor activeTextEditor]
                    (e.delete editor.selection)
                    (e.insert editor.selection.active output))))
        (return)))